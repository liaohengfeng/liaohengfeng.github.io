---
title: 图论总结
date: 2024-1-10 8:22:53
tags: ['图论','OI']
sticky: 240110
mathjax: ture
---

# 图论

---

## $0.$有感而发

>   _眼睛瞎了有利于打Dijkstra。_ by NotDeep
>
>   _如果这题我不会做，那么一定是图论。_ by NotDeep

---

## $1.$ 基本算法

​	$Case\ 1:$ **Dijkstra**

​		本质是 $贪心+DP$。

​		适用于非负权权图，保证当前取出的节点的最短路是**确定的**，是未确定最短路的节点中**最小的**。

​		常见题型 ： 补图，非负权图上用 *ta* ( $SPFA$已死 )。

​	$Case\ 2:$ **Floyd**

​		通过 $O(n^3)$ 的时间求出任意两点的最短路。**可以在负权图上使用。**

​		可以求 **最小环**,**传递闭包**。

​		下面对最小环进行说明:

```c++
//g[i][j]表示 i->j 的最短路,f[i][j]表示i->j的 边的长度
//把最短路拆成 (i-j) + (i>k,k->j)
//用 dji 可以做到 O(m(n+m)log m)
for(int k=1;k<=n;k++)
{
    for(int i=1;i<=k-1;i++)
        for(int j=i+1;j<=k-1;j++)
            ans=min(ans,f[i][k]+f[k][j]+g[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
            g[i][j]=min(g[i][k]+g[k][j],g[i][j]);
}
```

​	$Case\ 3:$ **Bellman–Ford**

​		从 **边** 的角度考虑最短路：

​			最短路的边的个数 **最多** 是 n-1。

​		如果 **边数** 大于了 n-1 , 说明原图上有负环。

​		通过 $for(i=1\ \rightarrow\ n)\ \ \ for([u,v] \in E)\ \ 松弛$ 可以让每一条边都走过。

​		但实际上跑不满，所以有了 $SPFA$。

​	$Case\ 4:$ **SPFA**

​		对$Case\ 3$的广搜优化，可以判负环。最坏 $O(nm)$。

​		优化点[这儿](https://www.luogu.com.cn/blog/Parabola/spfa-hacker-orzorz)。

---

## $2.$ 常见思路

​	$Case\ 1:$ 分层图最短路

​	$Case\ 2:$ Bellman–Ford 找负环

​	$Case\ 3:$ 跑完最短路后，在 最短路图(**DAG**) 上$DP$。

​	$Case\ 4:$ 多维最短路

​	$Case\ 5:$ 拆贡献/拆来源/YY长啥样

---

## $3.$ 魔改将至

​	$Case\ 1:$ 贪心

​		以$摄像头问题2$为例：

​			对于一段区间 $[l,r]$ 我们连接一条 $l \rightarrow r+1$ 的边，在连接 $i \rightarrow i-1\ ,i\in n$ 。

​			令 $dist_i$ 表示覆盖区间 $[1,i-1]$ 的代价，再跑最短路即可。

​	$Case\ 2:$ $DP$

​		以 [Wi-Fi](https://codeforces.com/problemset/problem/1216/F) 为例：

​			我们把每种操作转换为 带权区间覆盖 ， 就转回了 $摄像头2$。

---

<div STYLE="page-break-after: always;"></div>

## $4.$ 题目详解

#### 	$1.$ [$P4366$](https://www.luogu.com.cn/problem/P4366)

​	卡 $O(m\log m)$ 的 dji 的题目少的很，遇见就要珍惜。

​	考虑异或性质：
$$
x \oplus z=(x\oplus y) \oplus (y\oplus z)<=x\oplus y+y\oplus z
$$
​	对于每个节点，拆成 32 个节点: $\{v|v=x \oplus2^k,k\in N,v\leq n\}$，边数就会缩短成 $n\log n+m$。

#### $2.$ [神秘力量](http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2627&tid=Q)

​	先对补图进行概念阐述：

​		完全图-现有图=现有图的补图

​	维护时可以用堆乱搞或用链表维护。分别为 $O(m \log m)$ 和 $O(n)$。
