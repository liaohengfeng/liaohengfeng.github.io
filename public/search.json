[{"title":"23.12.9考试总结","url":"/2023/12/09/23.12.9%20%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","content":" 23.12.923.12.923.12.9 考试总结\n 分数 : 606060 （50+10+0+050+10+0+050+10+0+0)\n A. stick\n\n先是一个数字，然后一串000，最后一串888。贪就完了。\n注意模数是 9982449982449982448535353。挂分 50pts50pts50pts\n B. game\n\n正解爆搜。少打 break挂 90pts90pts90pts。\n答案很多，所以 yesyesyes 跑得很快。\n最坏情况5×65\\times 65×6，此时O(14×214×316)O(1^4\\times2^{14}\\times3^{16})O(14×214×316)。\n注意到数据很小，考虑可行性剪枝即可。\n来自 永远的7日之都 :\n\n C.  noip\n\n万恶的 O2O2O2，RE  0RE\\ \\ 0RE  0。\n字典序从大到小搜索,DPDPDP 预处理 每个后缀首字母确定的情况下所能得到的最大权值每个后缀首字母确定的情况下所能得到的最大权值每个后缀首字母确定的情况下所能得到的最大权值 ，判断当前是否 ≥ x\\geq\\ x≥ x (可行性剪枝)(可行性剪枝)(可行性剪枝)。\n\n学的是 DP作为部分DP作为部分DP作为部分 的思路。\n\n D. remove\n\n区间 DPDPDP。求\nmin{a×k+b×∑i=1k(maxi−mini)}min\n\\left\\{\n\\begin{aligned} \na \\times k + b\\times\\sum\\limits_{i=1}^{k} \\Big (max_i-min_i\\Big)\n\\end{aligned}\n\\right\\}\nmin⎩⎪⎨⎪⎧​a×k+b×i=1∑k​(maxi​−mini​)​⎭⎪⎬⎪⎫​\n设方程 fl,r,max,minf_{l,r,max,min}fl,r,max,min​ 表示 消除区间 [l,r][l,r][l,r] 使其剩下的最大值为 max ，最小值为 min 的最小代价。gl,rg_{l,r}gl,r​ 表示 区间[l,r][l,r][l,r]中全消的最小代价。\n所以\n\n\n\n 初始化 :\n\n\ngl,r=ming_{l,r}=mingl,r​=min{fl,r,max,min+a+b×(r−l)2f_{l,r,max,min}+a+b\\times (r-l)^2fl,r,max,min​+a+b×(r−l)2}\n\n\n 转移\n\n\n左边空或右边空 :\n\nfl,r,max,min=min⁡{gl,k+fk+1,r,max,min}f_{l,r,max,min}=\\min\\{g_{l,k} + f_{k+1,r,max,min}\\}fl,r,max,min​=min{gl,k​+fk+1,r,max,min​}\nfl,r,max,min=min⁡{gk+1,r+fl,k,max,min}f_{l,r,max,min}=\\min\\{g_{k+1,r} + f_{l,k,max,min}\\}fl,r,max,min​=min{gk+1,r​+fl,k,max,min​}\n\n两边都空\n\nfl,r,max,min=min⁡{fl,r,max,min+fk+1,r,max,min}f_{l,r,max,min}=\\min\\{f_{l,r,max,min} + f_{k+1,r,max,min}\\}fl,r,max,min​=min{fl,r,max,min​+fk+1,r,max,min​}\n\n端点刷表\n\nfl,r+1,max(max,wl),min(min,wr)=fl,r,max,minf_{l,r+1,max(max,w_l),min(min,w_r)}=f_{l,r,max,min}fl,r+1,max(max,wl​),min(min,wr​)​=fl,r,max,min​\n\n\n\n g?\ngl,r=ming_{l,r}=mingl,r​=min{fl,r,max,min+a+b×(max−min)2f_{l,r,max,min}+a+b\\times(max-min)^2fl,r,max,min​+a+b×(max−min)2}\n\n\n 离散化后 O(n4)O(n^4)O(n4)\n\n\n\n\n 问题：\n\n\n 手抄斩手，使用CV大发。\n\n\n O2O2O2 要看返回值。\n\n\n 对拍数据要把时间卡到满，不能放水。\n\n\n","tags":["OI"]},{"title":"CSP总结","url":"/2023/10/24/CSP/","content":" CSPCSPCSP 游记\n Day 0\n\n晚上去了酒店，和另外几个人一起复习了 TarjanTarjanTarjan ，然后就睡了。\n睡觉前想着 2.5h2.5h2.5h 写前两个题，后两个题打下暴力，应该能拿  一等。\n\n Day 1 + 上午\n\n7 : 407\\ :\\ 407 : 40\n早上起来的最早，但发现自己感冒了。喝了只 蒲地蓝蒲地蓝蒲地蓝 ，还戴上了 开喉剑开喉剑开喉剑 。\n心里有种不祥的预感，感觉 T3T3T3 会是与式子有关的 大模拟。\n$\\ $\n8 : 308\\ :\\ 308 : 30\n到一中集了合，拍了张照。果老师讲了些关于低级失误的事。\n$\\ $\n8 : 308\\ :\\ 308 : 30\n进了考场，发现座位设计非常 反人类，腿稍稍往前放一点就会碰到膝盖。\n题面与压缩包出现了分离，监考老师也搞了很久。\n$\\ $\n8 : 558\\ :\\ 558 : 55\nT1T1T1 感觉像约瑟夫，但 手搓样例 后发现每次会消掉 ⌊n−13⌋\\lfloor \\frac{n-1} {3} \\rfloor⌊3n−1​⌋ 个，while(n)while(n)while(n) 即可。\n对于第二个问，有一个显然的性质:\n\n在 nnn 消掉前，他一定在末尾。\n\n所以while(n)while(n)while(n)时判断一下 (n−1)%3==1(n-1)\\%3==1(n−1)%3==1 即可。\n$\\ $\n9 : 309\\ :\\ 309 : 30\n把 T1T1T1 的对拍打了一下，然后发现 T2T2T2 是贪心水题，15min15min15min 切了。\n$\\ $\n9 : 509\\ :\\ 509 : 50\n发现 T3T3T3 是二次函数求值，回想起了去年 T2T2T2 用 sqrtsqrtsqrt 爆精度，就筛了 1e61e61e6 内的质数。\n然后模拟即可。\n$\\ $\n11 : 0011\\ :\\ 0011 : 00\n把前三个题看了一遍，发现没问题，开冲 T4T4T4。\n$\\ $\n12 : 0012\\ :\\ 0012 : 00\n考试结束，预估\n$100\\ +\\ 100\\ +\\ 100\\ +\\ 10\\ =\\ 310  $ ， 感觉一等没问题。\n\n Day 1 + 下午\n\n2 : 302\\ :\\ 302 : 30\n进入了考场，pdfpdfpdf 的密码老师没找到，延迟了 5min5min5min。\n$\\ $\n3 : 003\\ :\\ 003 : 00\n发现 T1T1T1 是水题，枚举所有状态再反过来判断即可。\n$\\ $\n3 : 353\\ :\\ 353 : 35\nT2T2T2 先打了一个 O(n3)O(n^3)O(n3) 的暴力，然后发现枚举右端点太费时间，优化成了 O(n2)O(n^2)O(n2)\n$\\ $\n3 : 553\\ :\\ 553 : 55\n看了一下 T4T4T4 ，感觉像 树上DP ，但没推出来，转去了 T3T3T3。\n$\\ $\n6 : 006\\ :\\ 006 : 00\n一直在调 T3T3T3 ，感觉灵魂出窍。\n对其原则对其原则对其原则 很好做，但 444 操作难调得死，最后修修补补的过了大样例。\n考完发现没有初始化。\n$\\ $\n估分 100 + 50 + + ? + 0 = 150+100\\ +\\ 50\\ +\\ +\\ ?\\ +\\ 0\\ =\\ 150^+100 + 50 + + ? + 0 = 150+\n\n 反思\n\n比赛节奏感觉可以，SSS 组 T4T4T4 没看出来感觉很可惜。\n听说 JJJ 组的 T4T4T4 是分层图最短路，考场上自己没去想。\nSSS 组 T3T3T3 能拿多少是多少，得一等的希望就在他身上了。\n\n","tags":["CSP"]},{"title":"DP再次总结","url":"/2024/01/10/DP_2/","content":"## 1. 状态\n$\\ \\ \\ \\ 区间区间区间DP$的状态一般 设 f[l][r] 表示区间 [l][r] ....。但有些时候可以直接设 fif_ifi​ 表示 [1,i][1,i][1,i]…。\n$\\ \\ \\ \\ $转移的时候会依靠断点，即 f[l][r]=min/maxf[l][r]=min/maxf[l][r]=min/max{f[l][k]+f[k+1][r]f[l][k]+f[k+1][r]f[l][k]+f[k+1][r]}。\n$\\ \\ \\ \\ $常见的优化有两种 :\n\n\n   \t1. 四边形不等式\n\n\n\n   \t2. 递推\n\n\n\n 2.例题\n\n\n 表达式的亿种可能性\n\n直接算是不行的，我们要去乘上每一个数的代价。\n原因是 加法和减法可以交换顺序。\neg. : (1+1)+2 = 1+(1+2)(1+1)+2\\ =\\ 1+(1+2)(1+1)+2 = 1+(1+2)\n乘法具有分配率。\n\n\n\n 有味道的数字\n\n爆搜发现 max ans = 11max\\ ans\\ =\\ 11max ans = 11 , 且 $当且仅当\\ n=3\\ 或\\ n=7\\ $ 时，ans=−1ans=-1ans=−1。\n用 f[i] (f:vector)f[i]\\ (f:vector)f[i] (f:vector) 存 ansn = ians_n\\ =\\ iansn​ = i 的 nnn。\n\n\n\n 守卫\n\n题目具有迷惑性，容易想成单调栈。\n但发现加入点后需要一段区间的信息。\n所以直接区间 DPDPDP。\n枚举 rrr ,  l = r → 1l\\ =\\ r\\ \\rightarrow\\ 1l = r → 1，递推。\n\n\n\n 祖玛游戏 &amp;&amp; 单调栈\n\n打不过 (二维状态表示不完全) 就加入 (把表示不完全的信息加入状态)。\n实在不行还能加辅助数组。\n如果循环有后效性，或者循环讨论复杂，用 dfsdfsdfs。\n思想来源于二分 ： 把原问题转换为可行性问题\n\n\n\n 括号序列\n\n算重了怎么办？ 学习 $Catalan $ !\n我们知道\nCn+1=C0Cn+C1Cn−1+C2Cn−2+...+Cn−1C1+CnC0 (注意这里没有重复)C_{n+1}=C_0C_n+C_1C_{n-1}+C_2C_{n-2}+...+C_{n-1}C_1+C_nC_0\\ (注意这里没有重复)\nCn+1​=C0​Cn​+C1​Cn−1​+C2​Cn−2​+...+Cn−1​C1​+Cn​C0​ (注意这里没有重复)\n同理 , \n\n\n\n\n\n 3. 好题\n\n\nHDU - 2476 \n\n(空 -&gt; B) - (A -&gt; B)\n\n\n\nCodeForces - 149D \n\n高维状态 ：\nfl,r,x,yf_{l,r,x,y}fl,r,x,y​ 表示 区间[l,r][l,r][l,r]中，左端点是xxx,右端点是yyy的方案数。(左右端点均hash过)。\n\n\n\n262144  P\n\n状态不同于普通区间DPDPDP，类倍增，设的是\nfi,k 表示 从 i 开始直到合出 k 所需的最小长度。f_{i,k}\\ 表示\\ 从\\ i\\ 开始直到合出\\ k\\ 所需的最小长度。\nfi,k​ 表示 从 i 开始直到合出 k 所需的最小长度。\n\n\n\n\n\n 4.总结\n\n状态的根本问题是 : 如何用最简洁的信息使得答案能够被(不重复)，不遗漏的算出来。\n即使是 fl,rf_{l,r}fl,r​ 也是逃不过的。\n区间 DPDPDP 一般满足 一些局部最优解能凑出全局最优解，不行的话就得加维度。\n\n","tags":["OI","DP"]},{"title":"DP总结","url":"/2023/07/22/DP%E6%80%BB%E7%BB%93/","content":" DP总结\n 线性DP线性DP线性DP\n\n\n 定义:\n\n具有线性&quot;阶段&quot;划分的DPDPDP被称为线性DPDPDP。\n\n\n\n 经典模型\n\nLISLISLIS , LCSLCSLCS , LCISLCISLCIS(最长公共上升子序列) , 最长公共子序列最长公共子序列最长公共子序列 , 数字三角形数字三角形数字三角形。\n\n\n\n 例题：\n\n\n LCS\n 题意：\n\n求两个字符串中字典序最小的LCSLCSLCS。\n\n 方法:\n\n用 vectorvectorvector 记录下每一个状态下的答案。\n\n\n\n 最长上升子序列(LIS)\n 题意：\n\n\n给定一个长为 n 的序列 aia_iai​，求这个序列的最长单调上升子序列长度。\n要求 O(nlogn)O(n log_n)O(nlogn​) 。\n\n\n 方法：\n\n在长度一定的情况下，若结尾元素更小，那么最终答案也就更优。\n所以我们维护一个数组表示当前的LISLISLIS，每一次插入当前元素。\n\n code :\n#include&lt;bits/stdc++.h&gt;#define int long long#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)using namespace std;const int N=1e6 +3;int n,m,a[N],f[N];signed main()&#123;\tcin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];\tmemset(f,0x3f,sizeof f);\tfor(int i=1;i&lt;=n;i++) *upper_bound(f+1,f+n+1,a[i])=a[i];\tint res=1; while(f[res]!=f[0]) res++;\tcout&lt;&lt;res-1&lt;&lt;endl;\treturn 0;&#125;\n\n\n\n\n 二维平面上的DPDPDP 与 状态压缩DPDPDP\n\n\n 怎样判断？\n\n二维平面看题面。\n状态压缩的n≤22n\\le 22n≤22。\n\n\n\n 例题：\n\n\n Grid 2\n 题目：\n\n给一个 H×W 的网格，每一步只能向右或向下走，给出 nnn 个坐标，这些坐标对应的位置不能经过，求从左上角 (1,1)走到右下角 (H,W) 的方案数，答案对 109+710^9+7109+7 取模。\n\n 思路：\n\n首先对于 fi,j (1≤i≤H,1≤j≤W)f_{i,j}\\ (1\\le i\\le H,1\\le j\\le W)fi,j​ (1≤i≤H,1≤j≤W) 可行性显然，但空间不够。我们只能对着 nnn 个坐标开数组。\n我们设方程 fif_ifi​  表示从 (1,1) 做到第i个坐标，且只经过第iii个坐标的方案总数。\n那么，我们尝试使用容斥原理进行转移\n\n从 (1,1) 到 (xi,yix_i,y_ixi​,yi​) 的方案数是 Cxi−1+yi−1xi−1{C_{x_i-1+y_i-1}^{x_i -1}}Cxi​−1+yi​−1xi​−1​\n从某一个坐标转移过来的方案数是 $\\sum C_{x_i-x_j+y_i-y_j}^{x_i -x_j} $\n\n\n\n\n Matching\n 题目：\n\n给定 N，表示有 N 个男生和 N 个女生，再给你一个矩阵 a，如果ai,ja_{i,j}ai,j​ 等于 1，表示 i 这个男生和 j 这个女生可以匹配成一对，否则不能。 问要匹配 N 对的方案数。答案对 109+710^9+7109+7 取模。\n\n 思路：\n\n状压男生，枚举女生\n\n\n\n\n\n 区间DPDPDP\n​\t都离不开三重循环: ∑长度∑左端点∑转移的断点f...\\sum\\limits_{长度} \\sum\\limits_{左端点} \\sum\\limits_{转移的断点} f...长度∑​左端点∑​转移的断点∑​f...\n\n\n 石子合并\n 题目：\n\n在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n试设计出一个算法,计算出将 N* 堆石子合并成 1 堆的最小得分和最大得分。\n\n 思路：\n\n令dp[i][j]表示区间[i,j]的最小价值。\n不妨从终点考虑问题，即结果为两个子区间合并的最小值再加上合并需要的代价即可。\n枚举两个子区间，即枚举这个区间的中间点k，使这个区间被分为[i,k]和[k+1,j]两个区间，取一遍最小值加上合并的即为当前区间所求。\n至于合并的代价，用前缀和即可。\n所以dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1])\n\n\n\n Deque\n 题目：\n\n给定 N 个数的序列 AAA。\nA 和 B 轮流取数，每个人每次可以从序列头部或者尾部取走一个数（直到序列为空）。\nA 和 B 都希望自己取得的数的总和尽可能大。\n假设最优策略下，A 取得的数的总和是 X，B 取得的数的总和是 Y， 请输出 X-Y。\n\n 思路：\n\n显然游戏过程中剩下的数必然是连续的一段。设 fi,jf_{i,j}fi,j​ 表示剩下下标为 [i,j][i,j][i,j] 的数时，先手（并非当前的先手而是开始时的先手，下同）能取得的最大分数差。\n分两种情况讨论：\n\n已经取走的数为偶数个，此时先手取，fi,jf_{i,j}fi,j​=max⁡max⁡max⁡ (fi+1,j+aif_{i+1,j}+a_ifi+1,j​+ai​,fi,j−1f_{i,j-1}fi,j−1​,fi,j−1+ajf_{i,j-1}+a_jfi,j−1​+aj​)\n已经取走的数为奇数个，此时后手取，fi,jf_{i,j}fi,j​=maxmaxmax⁡ (fi+1,j−aif_{i+1,j}-a_ifi+1,j​−ai​,fi,j−1f_{i,j-1}fi,j−1​,fi,j−1−ajf_{i,j-1}-a_jfi,j−1​−aj​)\n\n\n\n\n 换根DPDPDP\n​\t本质上只是把序列变成了树\n\n\n Subtree\n 题目：\n\n有一个 n 个节点的树，对一些节点染色，使得所有被染色的节点是一个连通块。求对于 1,2,3,...,n1,2,3,...,n1,2,3,...,n每个节点，该节点被染色的方案个数。所有答案对 M 取模。\n\n 思路：\n\n我们设pip_ipi​表示以iii为跟的子树中的可行方案数,qiq_iqi​表示iii的父节点中除了iii的方案数。\n那么，有ansi=(qi+1)∗pians_i=(q_i+1)*p_iansi​=(qi​+1)∗pi​。\n\n\n\n DPDPDP优化\n​\t根据方程运用相应的数据结构即可。\n","tags":["OI","DP"]},{"title":"图论总结","url":"/2024/01/10/%E5%9B%BE%E8%AE%BA/","content":" 图论\n\n 0.0.0.有感而发\n\n眼睛瞎了有利于打Dijkstra。 by NotDeep\n如果这题我不会做，那么一定是图论。 by NotDeep\n\n\n 1.1.1. 基本算法\n​\tCase 1:Case\\ 1:Case 1: Dijkstra\n​\t\t本质是 贪心+DP贪心+DP贪心+DP。\n​\t\t适用于非负权权图，保证当前取出的节点的最短路是确定的，是未确定最短路的节点中最小的。\n​\t\t常见题型 ： 补图，非负权图上用 ta ( SPFASPFASPFA已死 )。\n​\tCase 2:Case\\ 2:Case 2: Floyd\n​\t\t通过 O(n3)O(n^3)O(n3) 的时间求出任意两点的最短路。可以在负权图上使用。\n​\t\t可以求 最小环,传递闭包。\n​\t\t下面对最小环进行说明:\n//g[i][j]表示 i-&gt;j 的最短路,f[i][j]表示i-&gt;j的 边的长度//把最短路拆成 (i-j) + (i&gt;k,k-&gt;j)//用 dji 可以做到 O(m(n+m)log m)for(int k=1;k&lt;=n;k++)&#123;    for(int i=1;i&lt;=k-1;i++)        for(int j=i+1;j&lt;=k-1;j++)            ans=min(ans,f[i][k]+f[k][j]+g[i][j]);\tfor(int i=1;i&lt;=n;i++)\t\tfor(int j=1;j&lt;=n;j++)            g[i][j]=min(g[i][k]+g[k][j],g[i][j]);&#125;\n​\tCase 3:Case\\ 3:Case 3: Bellman–Ford\n​\t\t从 边 的角度考虑最短路：\n​\t\t\t最短路的边的个数 最多 是 n-1。\n​\t\t如果 边数 大于了 n-1 , 说明原图上有负环。\n​\t\t通过 for(i=1 → n)   for([u,v]∈E)  松弛for(i=1\\ \\rightarrow\\ n)\\ \\ \\ for([u,v] \\in E)\\ \\ 松弛for(i=1 → n)   for([u,v]∈E)  松弛 可以让每一条边都走过。\n​\t\t但实际上跑不满，所以有了 SPFASPFASPFA。\n​\tCase 4:Case\\ 4:Case 4: SPFA\n​\t\t对Case 3Case\\ 3Case 3的广搜优化，可以判负环。最坏 O(nm)O(nm)O(nm)。\n​\t\t优化点这儿。\n\n 2.2.2. 常见思路\n​\tCase 1:Case\\ 1:Case 1: 分层图最短路\n​\tCase 2:Case\\ 2:Case 2: Bellman–Ford 找负环\n​\tCase 3:Case\\ 3:Case 3: 跑完最短路后，在 最短路图(DAG) 上DPDPDP。\n​\tCase 4:Case\\ 4:Case 4: 多维最短路\n​\tCase 5:Case\\ 5:Case 5: 拆贡献/拆来源/YY长啥样\n\n 3.3.3. 魔改将至\n​\tCase 1:Case\\ 1:Case 1: 贪心\n​\t\t以摄像头问题2摄像头问题2摄像头问题2为例：\n​\t\t\t对于一段区间 [l,r][l,r][l,r] 我们连接一条 l→r+1l \\rightarrow r+1l→r+1 的边，在连接 i→i−1 ,i∈ni \\rightarrow i-1\\ ,i\\in ni→i−1 ,i∈n 。\n​\t\t\t令 distidist_idisti​ 表示覆盖区间 [1,i−1][1,i-1][1,i−1] 的代价，再跑最短路即可。\n​\tCase 2:Case\\ 2:Case 2: DPDPDP\n​\t\t以 Wi-Fi 为例：\n​\t\t\t我们把每种操作转换为 带权区间覆盖 ， 就转回了 摄像头2摄像头2摄像头2。\n\n\n 4.4.4. 题目详解\n 1.1.1. P4366P4366P4366\n​\t卡 O(mlog⁡m)O(m\\log m)O(mlogm) 的 dji 的题目少的很，遇见就要珍惜。\n​\t考虑异或性质：\nx⊕z=(x⊕y)⊕(y⊕z)&lt;=x⊕y+y⊕zx \\oplus z=(x\\oplus y) \\oplus (y\\oplus z)&lt;=x\\oplus y+y\\oplus z\nx⊕z=(x⊕y)⊕(y⊕z)&lt;=x⊕y+y⊕z\n​\t对于每个节点，拆成 32 个节点: {v∣v=x⊕2k,k∈N,v≤n}\\{v|v=x \\oplus2^k,k\\in N,v\\leq n\\}{v∣v=x⊕2k,k∈N,v≤n}，边数就会缩短成 nlog⁡n+mn\\log n+mnlogn+m。\n 2.2.2. 神秘力量\n​\t先对补图进行概念阐述：\n​\t\t完全图-现有图=现有图的补图\n​\t维护时可以用堆乱搞或用链表维护。分别为 O(mlog⁡m)O(m \\log m)O(mlogm) 和 O(n)O(n)O(n)。\n","tags":["OI","图论"]}]